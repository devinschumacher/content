# How to Customize URL Patterns of Apps in Your Django Project Without Modifying Any App Settings

Topics: Django

In Django, the URL patterns of an app are typically defined in the app's `urls.py` file, and the project's `urls.py` file includes these patterns using the `include()` function. 

<aside>
❗ If you customize **app level information**, your edits will be erased everytime that app is updated and you download the update. This is why we will be editing app level settings at the **project level**

</aside>

# **Step 1: Import the App Views**

In your project's `urls.py` file, import the view functions from your app that you want to use.

```python
# project/urls.py

from app.views import index, collection, single, etc.
```

- Replace `app` with the name of your app.

# **Step 2: Define the Custom URL Patterns**

Next, define your custom URL patterns in the `urlpatterns` list for that app.

Normally we use `include()` like this:

```python
# project/urls.py

path("", include("app.urls", namespace="app")),
```

Instead of using `include()`, use the imported view functions directly and write your custom paths:

```python
# project/urls.py

from app.views import index, collection, single, etc.
# repeat for each app you want to customize

urlpatterns = [
    path("mycustompath/whatever/", index, name="boxing:index"),
    path("morecustomizing/boxers/<slug:slug>/", single, name="boxing:single"),
    # Repeat for every view/url pattern of the app
    # If a url requires no change, you must still enter it manually here

    # Repeat for each view of each app
]

```

With this setup, Django will use the `view functions` **from the app** but with the **URL patterns** you've defined here at the *project level.*

# **Step 3: Repeat for Each App**

Repeat the above steps for each app whose URLs you want to customize. 

Remember to import the view functions from each app and define the custom URL patterns.

# **Step 4: Verify the Custom URL Patterns**

Finally, verify that your custom URL patterns are working as expected. 

You can do this by running your Django server and navigating to the URLs in a web browser. 

By following these steps, you can customize the URL patterns of your apps at the project level without modifying any app settings. 

# Dont want a URL pattern to be available at all?

If you want to exclude URLs entirely from your project, just don’t include them.

**Note**: you must manually include all of the ones you want using the method above, because if you use the global `include()` then those URLs are coming.

Note: make sure that your apps handle this situation otherwise you’ll get 500 errors.

Excluding URLs from your project-level **`urls.py`** does not inherently cause an error. However, if in your code, you're referencing an excluded URL, issues can arise.

Consider the scenario where you have a template in your application where you're using Django's **`{% url %}`** template tag to generate a link to a view. The tag relies on the name of the view to produce the corresponding URL. If the URL of that view has been excluded from your project-level **`urls.py`**, Django will face an issue when it tries to render this template.

Because Django can't locate a URL pattern that matches the given view name, it will raise a **`NoReverseMatch`** exception. This exception will lead to an error page being displayed to the user.

In a live production environment where Django's DEBUG mode is turned off, this exception will result in a generic server error page, commonly referred to as an HTTP 500 error. This page is intentionally nondescript to avoid exposing sensitive application details to users or potential malicious actors.

So, when you're excluding URLs at the project level, it's crucial to ensure that these the apps are designed in such a way that they are able to handle missing URLs gracefully. This could be achieved through careful design of your apps and templates.

For example, one approach could be designing your apps to check whether a certain URL name exists before using it in the **`{% url %}`** template tag. If the URL name doesn't exist, the app could fall back to a default behavior, such as linking to a default page or not displaying the link at all.

This approach would allow you to exclude URLs at the project level without causing errors, while also keeping your apps modular and avoiding the need to modify app level code when excluding URLs.

^ not sure if this is true not sure how to do it yet