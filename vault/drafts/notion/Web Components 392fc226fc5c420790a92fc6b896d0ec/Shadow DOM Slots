# Shadow DOM Slots

Usually, if an element has shadow DOM, then its light DOM is not displayed. Slots allow to show elements from light DOM in specified places of shadow DOM.

Shadow DOM supportsÂ `<slot>`Â elements, that are automatically filled by the content from light DOM. 

If there are multiple elements in light DOM with the same slot name, they are appended into the slot, one after another.

The process of rendering slotted elements inside their slots is called â€œcompositionâ€. The result is called a â€œflattened DOMâ€.

**There are two kinds of slots:**

1. **Named slots**:Â `<slot name="X">...</slot>`Â â€“ gets light children withÂ `slot="X"`.
2. **Default slots**: the firstÂ `<slot>`Â without a name (subsequent unnamed slots are ignored) â€“ gets unslotted light children.

For example, this:

```jsx
<user-card>
  <span slot="username">John</span>
  <span slot="username">Smith</span>
</user-card>
```

Gives this flattened DOM with two elements inÂ `<slot name="username">`:

```jsx
<user-card>
  #shadow-root
    <div>Name:
      <slot name="username">
        <span slot="username">John</span>
        <span slot="username">Smith</span>
      </slot>
    </div>
    <div>Birthday:
      <slot name="birthday"></slot>
    </div>
</user-card>
```

<aside>
ğŸ’¡ TheÂ `slot="..."`Â attribute is only valid for direct children of the shadow host

</aside>

If we put something inside aÂ `<slot>`, it becomes the fallback, â€œdefaultâ€ content. The browser shows it if thereâ€™s no corresponding filler in light DOM.

## Default <slot>

The firstÂ `<slot>`Â in shadow DOM that doesnâ€™t have a name is a â€œdefaultâ€ slot.

It gets all nodes from the light DOM that arenâ€™t slotted elsewhere.

## Access & update slots

The browser monitors slots and updates the rendering if slotted elements are added/removed.

JavaScript can access slots using methods:

- `slot.assignedNodes/Elements()`Â â€“ returns nodes/elements inside theÂ `slot`.
- `node.assignedSlot`Â â€“ the reverse property, returns slot by a node.

## Monitoring slots

You can track slot contents using:

- `slotchange`Â event â€“ triggers the first time a slot is filled, and on any add/remove/replace operation of the slotted element, but not its children. The slot isÂ `event.target`.
- [MutationObserver](https://javascript.info/mutation-observer)Â to go deeper into slot content, watch changes inside it.

## Slot API

JavaScript looks at the â€œrealâ€ DOM, without flattening, but if the shadow tree hasÂ `{mode: 'open'}`, then we can figure out which elements assigned to a slot and, vice-versa, the slot by the element inside it:

- `node.assignedSlot`Â â€“ returns theÂ `<slot>`Â element that theÂ `node`Â is assigned to.
- `slot.assignedNodes({flatten: true/false})`Â â€“ DOM nodes, assigned to the slot. TheÂ `flatten`Â option isÂ `false`Â by default. If explicitly set toÂ `true`, then it looks more deeply into the flattened DOM, returning nested slots in case of nested components and the fallback content if no node assigned.
- `slot.assignedElements({flatten: true/false})`Â â€“ DOM elements, assigned to the slot (same as above, but only element nodes).

## TLDR

Slots allow to show elements from light DOM in specified places of shadow DOM; this process of rendering slotted elements inside their slots is called â€œcompositionâ€. The result is called a â€œflattened DOMâ€.

- Named slots:Â `<slot name="X">...</slot>`Â â€“ gets light children withÂ `slot="X"`.
- Default slot: the firstÂ `<slot>`Â without a name (subsequent unnamed slots are ignored) â€“ gets unslotted light children.
- If there are many elements for the same slot â€“ they are appended one after another.
- The content ofÂ `<slot>`Â element is used as a fallback. Itâ€™s shown if there are no light children for the slot.